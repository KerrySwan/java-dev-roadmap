Вольный перевод-конспект источника - <https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html>

Обзор:
  Зачем нужен Collection Framework:
  1. *Сокращение объёма/усилия разработки* через имплементацию решений готовых структур и алгоритмов
  2. *Улучшает производительность* через имплементацию готовых хай-перформанс алгоритмов и структур
  3. *Улучает взаимодействие несвязанных API* через общие коллекции
  4. *Сокращает усилия по разработке и внедрения АПИ* - проподает необходимость создания структур для конкретного случая
  5. *Способствует переиспользовыванию кода* через готовые интерфейсы стурктур данных

  Collection Framework состоит из:
  1. *Интерфейсы коллекций*
  2. *Имплементации общего порядка (основных)* - сеты, списки и т.д.
  3. *Устаревшие импелемнтаций* - Vector и Hashtable
  4. *Имплементации особого порядка* имплементации для особых ситуаций, со спецефичискими характеристиками
  5. *Многопоточные имплементации*
  6. *Импелементации-обёртки* обычно расширяют функциональность существующих импелемнтации
  7. *Выгодные-имплементации* маленькие высокопроизводительные имплементации
      (не уверен на счет перевода Convenience implementations) 
  8. *Абстрактные имплементации* частичные имплементации интерфейсов коллекций
  9. *Алгоритмы* сортировки и прочее
  10. *Инфраструктурные интерфейсы* 
  11. *Утиллиты массивов*

  Интерфейсы коллекций:
  Находятся в java.util

  1. Set - набор
  2. SortedSet - сортированый набор, необходим Comporator или имплементация Comparable
  3. NavigableSet - сортированный список дополненный методами навигации
  4. Queue - очередь
  5. concurent.BlockingQueue - очередь расширенная методами *ожидания при получении элемента, если учередь пуста* и *ожидания свободного места при добавлении элемента.*
  6. concurent.TransferQueue - очередь в которой происходит ожидание получения-извлечения элемента. Одновременно вставляется и извлекается один элемент.
  7. Deque - дэк
  8. concurent.BlockingDeque - Дэк расширенный методами *ожидания при получении элемента, если учередь пуста* и *ожидания свободного места при добавлении элемента.*

  Интерфейсы *НЕ* коллекций:

  1. SortedMap - сортированая таблица соотношений, необходим Comporator или имплементация Comparable
  2. NavigableMap - расширение SortedMap с методами навигации
  3. ConcurentMap - получение и удаление элементов реализовано в соотвествии с приоритетом потоков, обращающихся к таблице. Гарантируется атомарносить и потокобезопастность операций.
  4. NavigableConcurentMap - смесь пункта 2 и 3
  
  Дополнительные сведения:
    
    1. Многие методы расширенных интерфейсов помечены опциональными.
    2. Коллекции, которые не поддерживают операции модификации, помечены как *немодифицыруемые*
    3. Коллекции, которые дополнительно гарантируют, что никакие изменения не будут видимы, помечены как *неизменяемые*
    4. Списки, которые гарантируют, что их размер останется константой, даже если их элементы изменяется, называются *списками фиксированного размера*
    5. Списки, которые гарантируют доступ к элементам по индексу за постоянное время, называются *списками случайного доступа.* Списки, которые не гарантируют такой доступ, называются *списаками последовательного доступа.* Интерфейс RandomAccess промечает списки, которые поддерживают случайный доступ

    Некоторые имплементации ограничивают какие элементы могут быть в них храниться. 
    Возможные ограниечния -
    1. Быть определенного типа
    2. Не быть null
    3. Подчиняться какому либо правилу/предикату.

    Имплементации коллекций:

      | Interface || Hash Table | Resizable Array | Balanced Tree | Linked List | Hash Table + Linked List
      ----------------------------------------------------------------------------------------------------
      | Set       || Hash Set   |                 | TreeSet       |             | LinkedHashSet
      | List      ||            | ArrayList       |               | LinkedList  | 
      | Deque     ||            | ArrayDeque      |               | LinkedList  | 
      | Map       || Hash Map   |                 | TreeMap       |             | LinkedHashMap

      Все имплементации общего порядка поддерживают все опциональные методы и не имеют ограничений на элементы, которые они  могут содержать. Все они несинхронизированы, но все коллекции содержат статические фабрики называемые *синхронизированные обертки*, которые могут быть использованны, что бы добавить синхронизацию, ко многи несинхронизированным коллекциям. Все новые имплементации имеют fail-fast итераторы, которые обнаруживают одновременные/многопоточные изменения, и быстро прекращают свою работу.

    Многопоточные коллекции:

      Не связанны с "синхронизированными обёртками"

      Интерфейсы:
        1. BlockingQueue
        2. TransferQueue
        3. BlockingDeque
        4. ConcurrentMap
        5. ConcurrentNavigableMap

      Имплементации:
        1. LinkedBlockingQueue
        2. ArrayBlockingQueue
        3. PriorityBlockingQueue
        4. DelayQueue
        5. SynchronousQueue
        6. LinkedBlockingDeque
        7. LinkedTransferQueue
        8. CopyOnWriteArrayList
        9. CopyOnWriteArraySet
        10. ConcurrentSkipListSet
        11. ConcurrentHashMap
        12. ConcurrentSkipListMap

      Цели разработки:
        Основной целью является создание API небольшого размера (дальше указан термин "conceptual weight", предполагаю имелось ввиду размер и сложность кода). Было критично то, что бы новый функционал не казался слишком сложным для уже практикующих программистов Java; функционал должен был расширять текущие возможности, нежели заменять их. В то же время, новый API должен был быть достаточно мощным, что бы обеспечить все приимущества описанные ранее. 

        Для поддержания маленького колличества интерфейсов, они не предполагали охватить такие мелкие отличия как изменяемость, модифицируемость и изменение размера. Наоборот, такой функционал в основные интерфейсах помечен как опциональный, позволящий имплементациям выбрасывать UnsupportedOperationException для индикации того, что объявленные операции не поддерживаются.