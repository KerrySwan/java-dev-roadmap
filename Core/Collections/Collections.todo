Вольный перевод-конспект источника - <https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html>

Обзор:
  Зачем нужен Collection Framework:
  1. *Сокращение объёма/усилия разработки* через имплементацию решений готовых структур и алгоритмов
  2. *Улучшает производительность* через имплементацию готовых хай-перформанс алгоритмов и структур
  3. *Улучает взаимодействие несвязанных API* через общие коллекции
  4. *Сокращает усилия по разработке и внедрения АПИ* - проподает необходимость создания структур для конкретного случая
  5. *Способствует переиспользовыванию кода* через готовые интерфейсы стурктур данных

  Collection Framework состоит из:
  1. *Интерфейсы коллекций*
  2. *Имплементации общего порядка (основных)* - сеты, списки и т.д.
  3. *Устаревшие импелемнтаций* - Vector и Hashtable
  4. *Имплементации особого порядка* имплементации для особых ситуаций, со спецефичискими характеристиками
  5. *Многопоточные имплементации*
  6. *Импелементации-обёртки* обычно расширяют функциональность существующих импелемнтации
  7. *Выгодные имплементации* маленькие высокопроизводительные имплементации
      (не уверен на счет перевода Convenience implementations) 
  8. *Абстрактные имплементации* частичные имплементации интерфейсов коллекций
  9. *Алгоритмы* сортировки и прочее
  10. Инфраструктурные интерфейсы* 
  11. Утиллиты массивов*

  Интерфейсы коллекций:
  Находятся в java.util

  1. Set - набор
  2. SortedSet - сортированый набор, необходим Comporator или имплементация Comparable
  3. NavigableSet - сортированный список дополненный методами навигации
  4. Queue - очередь
  5. concurent.BlockingQueue - очередь расширенная методами *ожидания при получении элемента, если учередь пуста* и *ожидания свободного места при добавлении элемента.*
  6. concurent.TransferQueue - очередь в которой происходит ожидание получения-извлечения элемента. Одновременно вставляется и извлекается один элемент.
  7. Deque - дэк
  8. concurent.BlockingDeque - Дэк расширенный методами *ожидания при получении элемента, если учередь пуста* и *ожидания свободного места при добавлении элемента.*
  9. List - его кстати нет на оф страничке

  Интерфейсы *НЕ* коллекций:

  1. Map
  2. SortedMap - сортированая таблица соотношений, необходим Comporator или имплементация Comparable
  3. NavigableMap - расширение SortedMap с методами навигации
  4. ConcurentMap - получение и удаление элементов реализовано в соотвествии с приоритетом потоков, обращающихся к таблице. Гарантируется атомарносить и потокобезопастность операций.
  5. NavigableConcurentMap - смесь пункта 2 и 3
  
  Дополнительные сведения:
    
    1. Многие методы расширенных интерфейсов помечены опциональными.
    2. Коллекции, которые не поддерживают операции модификации, помечены как *немодифицыруемые* (не поддерживают remove и clear)
    3. Коллекции, которые дополнительно гарантируют, что никакие изменения не будут видимы, помечены как *неизменяемые*
    4. Списки, которые гарантируют, что их размер останется константой, даже если их элементы изменяется, называются *списками фиксированного размера*
    5. Списки, которые гарантируют доступ к элементам по индексу за постоянное время, называются *списками случайного доступа.* Списки, которые не гарантируют такой доступ, называются *списаками последовательного доступа.* Интерфейс RandomAccess промечает списки, которые поддерживают случайный доступ

    Некоторые имплементации ограничивают какие элементы могут быть в них храниться. 
    Возможные ограниечния -
    1. Быть определенного типа
    2. Не быть null
    3. Подчиняться какому либо правилу/предикату.

    Имплементации коллекций:

      | Interface || Hash Table | Resizable Array | Balanced Tree | Linked List | Hash Table + Linked List
      ----------------------------------------------------------------------------------------------------
      | Set       || Hash Set   |                 | TreeSet       |             | LinkedHashSet
      | List      ||            | ArrayList       |               | LinkedList  | 
      | Deque     ||            | ArrayDeque      |               | LinkedList  | 
      | Map       || Hash Map   |                 | TreeMap       |             | LinkedHashMap

      Все имплементации общего порядка поддерживают все опциональные методы и не имеют ограничений на элементы, которые они  могут содержать. Все они несинхронизированы, но все коллекции содержат статические фабрики называемые *синхронизированные обертки*, которые могут быть использованны, что бы добавить синхронизацию, ко многи несинхронизированным коллекциям. Все новые имплементации имеют fail-fast итераторы, которые обнаруживают одновременные/многопоточные изменения, и быстро прекращают свою работу.

    Многопоточные коллекции:

      Не связанны с "синхронизированными обёртками"

      Интерфейсы:
        1. BlockingQueue
        2. TransferQueue
        3. BlockingDeque
        4. ConcurrentMap
        5. ConcurrentNavigableMap

      Имплементации:
        1. LinkedBlockingQueue
        2. ArrayBlockingQueue
        3. PriorityBlockingQueue
        4. DelayQueue
        5. SynchronousQueue
        6. LinkedBlockingDeque
        7. LinkedTransferQueue
        8. CopyOnWriteArrayList
        9. CopyOnWriteArraySet
        10. ConcurrentSkipListSet
        11. ConcurrentHashMap
        12. ConcurrentSkipListMap

      Цели разработки:
        Основной целью является создание API небольшого размера (дальше указан термин "conceptual weight", предполагаю имелось ввиду размер и сложность кода). Было критично то, что бы новый функционал не казался слишком сложным для уже практикующих программистов Java; функционал должен был расширять текущие возможности, нежели заменять их. В то же время, новый API должен был быть достаточно мощным, что бы обеспечить все приимущества описанные ранее. 

        Для поддержания маленького колличества интерфейсов, они не предполагали охватить такие мелкие отличия как изменяемость, модифицируемость и изменение размера. Наоборот, такой функционал в основные интерфейсах помечен как опциональный, позволящий имплементациям выбрасывать UnsupportedOperationException для индикации того, что объявленные операции не поддерживаются.

      Дополнительно:

        Это должно было быть в начале, но на официальном ресурсе этого нет.
        Все коллекции и не-коллекции являются имплементациями двух интерфейсов -
          1. Iterable
          2. Map
        Подинтерфейсом Iterable является Collection.
        То есть имеем такую иерархию зависимостей, в соотвествии с javadoc

          Iterable <--- Collection <--- List  <--- ...
                                   <--- Set   <--- ...
                                   <--- Queue <--- ...  
                                   <--- Deque <--- ...

          Map <--- SortedMap <--- NavigableMap <--- ...
                             <--- ConcurentNavigableMap <--- ...

Практика и javadoc:

  Постараюсь здесь описать основные реализации классов в фомате спуска по иерархии.

  Set:

    Примеры в файле SetsEdu.java

    Содержит два подинтерфейса
      1. SortedSet
      2. NavigableSet
      NavigableSet является потомком SortedSet

    Реализации "чистого" set
      1. EnumSet
      2. HashSet
      3. LinkedHashSet

    Дальше под словосочитанием "чистая реализация/имплементация" буду понимать конкретные классы, которые напрямую зависимы от интерфейса, без промежуточных зависимостей

    SortedSet не имеет ни одной чистой реализации.
    Однако его подинтерфейс NavigableSet имеет две
      1. TreeSet
      2. ConcurrentSkipListSet


    EnumSet:

      Документация описывает как набор который позволяет сохранять Enum'ы.
      Является типо-безопасной альтернативой традиционным "битовым флагам".
      Опреации с множеством значений (removeAll, containsAll) выполняются за константное время.
      Не поддерживает _вставку_ null.
      Не синхронизирован. Для синхронизации должен быть обёрнут так
        Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class))

      EnumSet абстрактен. Объявляется он через
        _EnumSet.of(...)_



Чеклист теории:
  5 Целей фреймворка
  11 Структурных элементов
  9 Интерфейсов коллекций
  4 Интерфейсов не коллекций
  5 Многопоточных интерфейсов
  12 Многопоточных реализаций