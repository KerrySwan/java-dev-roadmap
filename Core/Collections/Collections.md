Вольный перевод-конспект [источника](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html)

#Collection Framework

##Обзор:
####Зачем нужен Collection Framework:

1. *Сокращение объёма/усилия разработки* через имплементацию решений готовых структур и алгоритмов
2. *Улучшает производительность* через имплементацию готовых хай-перформанс алгоритмов и структур
3. *Улучает взаимодействие несвязанных API* через общие коллекции
4. *Сокращает усилия по разработке и внедрения АПИ* - проподает необходимость создания структур для конкретного случая
5. *Способствует переиспользовыванию кода* через готовые интерфейсы стурктур данных

###Collection Framework состоит из:

1. *Интерфейсы коллекций*
2. *Имплементации общего порядка (основных)* - сеты, списки и т.д.
3. *Устаревшие импелемнтаций* - Vector и Hashtable
4. *Имплементации особого порядка* имплементации для особых ситуаций, со спецефичискими характеристиками
5. *Многопоточные имплементации*
6. *Импелементации-обёртки* обычно расширяют функциональность существующих импелемнтации
7. *Выгодные имплементации* маленькие высокопроизводительные имплементации
   (не уверен на счет перевода Convenience implementations)
8. *Абстрактные имплементации* частичные имплементации интерфейсов коллекций
9. *Алгоритмы* сортировки и прочее
10. *Инфраструктурные интерфейсы*
11. *Утиллиты массивов*

###Интерфейсы коллекций:
Находятся в java.util

1. Set - набор
2. SortedSet - сортированый набор, необходим Comporator или имплементация Comparable
3. NavigableSet - сортированный список дополненный методами навигации
4. Queue - очередь
5. concurent.BlockingQueue - очередь расширенная методами *ожидания при получении элемента, если учередь пуста* и *ожидания свободного места при добавлении элемента.*
6. concurent.TransferQueue - очередь в которой происходит ожидание получения-извлечения элемента. Одновременно вставляется и извлекается один элемент.
7. Deque - дэк
8. concurent.BlockingDeque - Дэк расширенный методами *ожидания при получении элемента, если учередь пуста* и *ожидания свободного места при добавлении элемента.*
9. List - его кстати нет на оф страничке

###Интерфейсы _**НЕ**_ коллекций:

1. Map
2. SortedMap - сортированая таблица соотношений, необходим Comporator или имплементация Comparable
3. NavigableMap - расширение SortedMap с методами навигации
4. ConcurentMap - получение и удаление элементов реализовано в соотвествии с приоритетом потоков, обращающихся к таблице. Гарантируется атомарносить и потокобезопастность операций.
5. NavigableConcurentMap - смесь пункта 2 и 3

###Дополнительные сведения:

1. Многие методы расширенных интерфейсов помечены опциональными.
2. Коллекции, которые не поддерживают операции модификации, помечены как *немодифицыруемые* (не поддерживают remove и clear)
3. Коллекции, которые дополнительно гарантируют, что никакие изменения не будут видимы, помечены как *неизменяемые*
4. Списки, которые гарантируют, что их размер останется константой, даже если их элементы изменяется, называются *списками фиксированного размера*
5. Списки, которые гарантируют доступ к элементам по индексу за постоянное время, называются *списками случайного доступа.* Списки, которые не гарантируют такой доступ, называются *списаками последовательного доступа.* Интерфейс RandomAccess промечает списки, которые поддерживают случайный доступ

Некоторые имплементации ограничивают какие элементы могут быть в них храниться.
####Возможные ограниечния:

1. Быть определенного типа
2. Не быть null
3. Подчиняться какому либо правилу/предикату.

####Некоторые имплементации коллекций:


| Interface | Hash Table | Resizable Array | Balanced Tree | Linked List | Hash Table + Linked List |
| :---------- | :----------: | :---------------: | :-------------: | :-----------: | -------------------------: |
| Set       |  Hash Set  |                |    TreeSet    |            |            LinkedHashSet |
| List      |            |    ArrayList    |              | LinkedList |                          |
| Deque     |            |   ArrayDeque   |              | LinkedList |                          |
| Map       |  Hash Map  |                |    TreeMap    |            |            LinkedHashMap |

Все имплементации общего порядка поддерживают все опциональные методы и не имеют ограничений на элементы, которые они  могут содержать. Все они несинхронизированы, но все коллекции содержат статические фабрики называемые *синхронизированные обертки*, которые могут быть использованны, что бы добавить синхронизацию, ко многи несинхронизированным коллекциям. Все новые имплементации имеют fail-fast итераторы, которые обнаруживают одновременные/многопоточные изменения, и быстро прекращают свою работу.

###Многопоточные коллекции:
Не связанны с "синхронизированными обёртками"

####Интерфейсы:

1. BlockingQueue
2. TransferQueue
3. BlockingDeque
4. ConcurrentMap
5. ConcurrentNavigableMap

####Имплементации:

1. LinkedBlockingQueue
2. ArrayBlockingQueue
3. PriorityBlockingQueue
4. DelayQueue
5. SynchronousQueue
6. LinkedBlockingDeque
7. LinkedTransferQueue
8. CopyOnWriteArrayList
9. CopyOnWriteArraySet
10. ConcurrentSkipListSet
11. ConcurrentHashMap
12. ConcurrentSkipListMap

###Цели разработки:
Основной целью является создание API небольшого размера (дальше указан термин "conceptual weight", предполагаю имелось ввиду размер и сложность кода). Было критично то, что бы новый функционал не казался слишком сложным для уже практикующих программистов Java; функционал должен был расширять текущие возможности, нежели заменять их. В то же время, новый API должен был быть достаточно мощным, что бы обеспечить все приимущества описанные ранее.
Для поддержания маленького колличества интерфейсов, они не предполагали охватить такие мелкие отличия как изменяемость, модифицируемость и изменение размера. Наоборот, такой функционал в основные интерфейсах помечен как опциональный, позволящий имплементациям выбрасывать UnsupportedOperationException для индикации того, что объявленные операции не поддерживаются.

###Дополнительно:
Это должно было быть в начале, но на официальном ресурсе этого нет.
Все коллекции и не-коллекции являются имплементациями двух интерфейсов -

1. Iterable
2. Map
   Подинтерфейсом Iterable является Collection.
   То есть имеем такую иерархию зависимостей, в соотвествии с javadoc

```
   Iterable <--- Collection <--- List  <--- ...
                            <--- Set   <--- ...
                            <--- Queue <--- ...  
                            <--- Deque <--- ...

        Map <--- SortedMap  <--- NavigableMap <--- ...
                            <--- ConcurentNavigableMap <--- ...
```

##Практика и javadoc:
Постараюсь здесь описать основные реализации классов в фомате спуска по иерархии.

###Set:

Примеры в файле SetsEdu.java

####Содержит два подинтерфейса:

1. SortedSet
2. NavigableSet
   NavigableSet является потомком SortedSet

####Реализации "чистого" set:

1. EnumSet
2. HashSet
3. LinkedHashSet

*Дальше под словосочитанием "чистая реализация/имплементация" буду понимать конкретные классы, которые напрямую зависимы от интерфейса, без промежуточных зависимостей*

SortedSet не имеет ни одной чистой реализации.
Однако его подинтерфейс NavigableSet имеет две:

1. TreeSet
2. ConcurrentSkipListSet

####EnumSet:
Документация описывает как набор который позволяет сохранять Enum'ы.
Является типо-безопасной альтернативой традиционным "битовым флагам".
Опреации с множеством значений (removeAll, containsAll) выполняются за константное время.
Не поддерживает __вставку__ null.
Не синхронизирован. Для синхронизации должен быть обёрнут так
`Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class))`

EnumSet абстрактен. Объявляется он через
`EnumSet.of(...)`

[Битовые флаги](https://ru.wikipedia.org/wiki/%D0%A4%D0%BB%D0%B0%D0%B3_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%D0%B0))
####HashSet
Реализация интерфейса Set. На самом деле происходит вызов инстанса HashMap.
Соотвественно можно сделать вывод, что для корректной работы нужна перезапись методов
hashCode и equals. Вывод элементов не гарантирован в порядке добавления.

<p>За константное время производит базовые операции add, remove, contains и size в случае
если распределение элементов хеш-функцией, между баккитов HashMap, происходит правильно.<p>

Синхронизация: `Set s = Collections.synchronizedSet(new HashSet(...));`

Поддерживает вставку одного null.

`(На самом деле, до настоящего момента, я никогда не проверял как происходит инициализация такого набора. Но это очень забавно. Там буквально написано new HashMap.)`

####LinkedHashSet
Реализация Set с поддержкой linkedList и HashMap. Происходит инициализация LinkedHashMap.
Реализация линковки элементов - двухстороняя. Гарантирует вывод в порядке добавления. Добавление элемента не поменяет его позицию при выводе, 
в случае если элемент уже находится в наборе.<p>

Синхронизация ```Set s = Collections.synchronizedSet(new LinkedHashSet(...));```

####TreeSet
Является имплементацией NavigableSet. Содержит инстанс TreeMap (это уже перестало меня смешить).
Элементы которые помещаются в TreeSet должны либо наследовать [Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html),
либо в сам сет должен быть передан [Comporator](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html).
Для базовых операций add, remove, contains гарантированное время исполнения log(n).
Так же надо учитывать, что правильная имплементация Set гарантрована только в случае,
если equals и compareTo/compare при равенстве элементов работают согласованно. Без согласованности, сет будет работать
но будет нарушен главные контракт с Set.<p>

Синхронизация:`SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));`

Под капотом [красно-черное дерево](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D1%91%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE).

####CopyOnWriteArraySet
Имплементаиця Set. Использует реализацию CopyOnWriteArrayList.<p>
1. Лучший выбор для приложений, которые не наращивают объемы данных и операции
чтения сильно превышают операции изменения.
2. Потокобезопасная реализация
3. Операции изменения очень затратны, т.к копируют весь набор данных
4. Итераторы не поддерживают операции изменения
5. Итераторы быстры и не могут быть затронуты другими потоками, т.к. они
зависят от отдельных снапшотов данных, сделаных во время вызова итератора.
 

####ConcurrentSkipListSet
Имплементаиця NavigableSet

###Чеклист теории:

```
5 Целей фреймворка
11 Структурных элементов
9 Интерфейсов коллекций
4 Интерфейсов не коллекций
5 Многопоточных интерфейсов
12 Многопоточных реализаций

6 реализаций Set (2 многопоточные)
```
