# Collection Framework

## Обзор:
#### Зачем нужен Collection Framework:

1. *Сокращение объёма/усилия разработки* через имплементацию решений готовых структур и алгоритмов
2. *Улучшает производительность* через имплементацию готовых хай-перформанс алгоритмов и структур
3. *Улучает взаимодействие несвязанных API* через общие коллекции
4. *Сокращает усилия по разработке и внедрения АПИ* - проподает необходимость создания структур для конкретного случая
5. *Способствует переиспользовыванию кода* через готовые интерфейсы стурктур данных

### Collection Framework состоит из:

1. *Интерфейсы коллекций*
2. *Имплементации общего порядка (основных)* - сеты, списки и т.д.
3. *Устаревшие импелемнтаций* - Vector и Hashtable
4. *Имплементации особого порядка* имплементации для особых ситуаций, со спецефичискими характеристиками
5. *Многопоточные имплементации*
6. *Импелементации-обёртки* обычно расширяют функциональность существующих импелемнтации
7. *Выгодные имплементации* маленькие высокопроизводительные имплементации
   (не уверен на счет перевода Convenience implementations)
8. *Абстрактные имплементации* частичные имплементации интерфейсов коллекций
9. *Алгоритмы* сортировки и прочее
10. *Инфраструктурные интерфейсы*
11. *Утиллиты массивов*

### Интерфейсы коллекций:
Находятся в java.util

1. Set - набор
2. SortedSet - сортированый набор, необходим Comporator или имплементация Comparable
3. NavigableSet - сортированный список дополненный методами навигации
4. Queue - очередь
5. concurent.BlockingQueue - очередь расширенная методами *ожидания при получении элемента, если учередь пуста* и *ожидания свободного места при добавлении элемента.*
6. concurent.TransferQueue - очередь в которой происходит ожидание получения-извлечения элемента. Одновременно вставляется и извлекается один элемент.
7. Deque - дэк
8. concurent.BlockingDeque - Дэк расширенный методами *ожидания при получении элемента, если учередь пуста* и *ожидания свободного места при добавлении элемента.*
9. List - его кстати нет на оф страничке

### Интерфейсы _**НЕ**_ коллекций:

1. Map
2. SortedMap - сортированая таблица соотношений, необходим Comporator или имплементация Comparable
3. NavigableMap - расширение SortedMap с методами навигации
4. ConcurentMap - получение и удаление элементов реализовано в соотвествии с приоритетом потоков, обращающихся к таблице. Гарантируется атомарносить и потокобезопастность операций.
5. NavigableConcurentMap - смесь пункта 2 и 3

### Дополнительные сведения:

1. Многие методы расширенных интерфейсов помечены опциональными.
2. Коллекции, которые не поддерживают операции модификации, помечены как *немодифицыруемые* (не поддерживают remove и clear)
3. Коллекции, которые дополнительно гарантируют, что никакие изменения не будут видимы, помечены как *неизменяемые*
4. Списки, которые гарантируют, что их размер останется константой, даже если их элементы изменяется, называются *списками фиксированного размера*
5. Списки, которые гарантируют доступ к элементам по индексу за постоянное время, называются *списками случайного доступа.* Списки, которые не гарантируют такой доступ, называются *списаками последовательного доступа.* Интерфейс RandomAccess промечает списки, которые поддерживают случайный доступ

Некоторые имплементации ограничивают какие элементы могут быть в них храниться.
#### Возможные ограниечния:

1. Быть определенного типа
2. Не быть null
3. Подчиняться какому либо правилу/предикату.

#### Некоторые имплементации коллекций:


| Interface | Hash Table | Resizable Array | Balanced Tree | Linked List | Hash Table + Linked List |
|:----------| :--------: | :------------: |:-------------:| :--------: |-------------------------:|
| Set       |  Hash Set  |                |    TreeSet    |            |            LinkedHashSet |
| List      |            |    ArrayList   |               | LinkedList |                          |
| Deque     |            |   ArrayDeque   |               | LinkedList |                          |
| Map       |  Hash Map  |                |    TreeMap    |            |            LinkedHashMap |

Все имплементации общего порядка поддерживают все опциональные методы и не имеют ограничений на элементы, которые они  могут содержать. Все они несинхронизированы, но все коллекции содержат статические фабрики называемые *синхронизированные обертки*, которые могут быть использованны, что бы добавить синхронизацию, ко многи несинхронизированным коллекциям. Все новые имплементации имеют fail-fast итераторы, которые обнаруживают одновременные/многопоточные изменения, и быстро прекращают свою работу.

### Многопоточные коллекции:
Не связанны с "синхронизированными обёртками"

#### Интерфейсы:

1. BlockingQueue
2. TransferQueue
3. BlockingDeque
4. ConcurrentMap
5. ConcurrentNavigableMap

#### Имплементации:

1. LinkedBlockingQueue
2. ArrayBlockingQueue
3. PriorityBlockingQueue
4. DelayQueue
5. SynchronousQueue
6. LinkedBlockingDeque
7. LinkedTransferQueue
8. CopyOnWriteArrayList
9. CopyOnWriteArraySet
10. ConcurrentSkipListSet
11. ConcurrentHashMap
12. ConcurrentSkipListMap

### Цели разработки:
Основной целью является создание API небольшого размера (дальше указан термин "conceptual weight", предполагаю имелось ввиду размер и сложность кода). Было критично то, что бы новый функционал не казался слишком сложным для уже практикующих программистов Java; функционал должен был расширять текущие возможности, нежели заменять их. В то же время, новый API должен был быть достаточно мощным, что бы обеспечить все приимущества описанные ранее.
Для поддержания маленького колличества интерфейсов, они не предполагали охватить такие мелкие отличия как изменяемость, модифицируемость и изменение размера. Наоборот, такой функционал в основные интерфейсах помечен как опциональный, позволящий имплементациям выбрасывать UnsupportedOperationException для индикации того, что объявленные операции не поддерживаются.

### Дополнительно:
Это должно было быть в начале, но на официальном ресурсе этого нет.
Все коллекции и не-коллекции являются имплементациями двух интерфейсов -

1. Iterable
2. Map
   Подинтерфейсом Iterable является Collection.
   То есть имеем такую иерархию зависимостей, в соотвествии с javadoc

```
   Iterable <--- Collection <--- List  <--- ...
                            <--- Set   <--- ...
                            <--- Queue <--- Deque <--- ...
                                       <--- ... 

        Map <--- SortedMap  <--- NavigableMap <--- ...
                            <--- ConcurentNavigableMap <--- ...
```

## Практика и javadoc:
Постараюсь здесь описать основные реализации классов в фомате спуска по иерархии.

## Set:

Примеры в файле SetsEdu.java

#### Содержит два подинтерфейса:

1. SortedSet
2. NavigableSet
   NavigableSet является потомком SortedSet

#### Реализации "чистого" set:

1. EnumSet
2. HashSet
3. LinkedHashSet

*Дальше под словосочитанием "чистая реализация/имплементация" буду понимать конкретные классы, которые напрямую зависимы от интерфейса, без промежуточных зависимостей*

Реализации SortedSet и NavigableSet:

1. TreeSet
2. ConcurrentSkipListSet

#### EnumSet:
Документация описывает как набор который позволяет сохранять Enum'ы.
Является типо-безопасной альтернативой традиционным "битовым флагам".
Опреации с множеством значений (removeAll, containsAll) выполняются за константное время.
Не поддерживает __вставку__ null.
Не синхронизирован. Для синхронизации должен быть обёрнут так
`Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class))`

EnumSet абстрактен. Объявляется он через
`EnumSet.of(...)`

[Битовые флаги](https://ru.wikipedia.org/wiki/%D0%A4%D0%BB%D0%B0%D0%B3_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%D0%B0))

#### HashSet
Реализация интерфейса Set. На самом деле происходит вызов инстанса HashMap.
Соотвественно можно сделать вывод, что для корректной работы нужна перезапись методов
hashCode и equals. Вывод элементов не гарантирован в порядке добавления.

<p>За константное время производит базовые операции add, remove, contains и size в случае
если распределение элементов хеш-функцией, между баккитов HashMap, происходит правильно.<p>

Синхронизация: `Set s = Collections.synchronizedSet(new HashSet(...));`

Поддерживает вставку одного null.

`(На самом деле, до настоящего момента, я никогда не проверял как происходит инициализация такого набора. Но это очень забавно. Там буквально написано new HashMap.)`

#### LinkedHashSet
Реализация Set с поддержкой linkedList и HashMap. Происходит инициализация LinkedHashMap.
Реализация линковки элементов - двухстороняя. Гарантирует вывод в порядке добавления. Добавление элемента не поменяет его позицию при выводе,
в случае если элемент уже находится в наборе.<p>

Синхронизация ```Set s = Collections.synchronizedSet(new LinkedHashSet(...));```

#### TreeSet
Является имплементацией NavigableSet. Содержит инстанс TreeMap (это уже перестало меня смешить).
Элементы которые помещаются в TreeSet должны либо наследовать [Comparable](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html),
либо в сам сет должен быть передан [Comporator](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html).
Для базовых операций add, remove, contains гарантированное время исполнения log(n).
Так же надо учитывать, что правильная имплементация Set гарантрована только в случае,
если equals и compareTo/compare при равенстве элементов работают согласованно. Без согласованности, сет будет работать
но будет нарушен главные контракт с Set.<p>

Синхронизация:`SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));`

Под капотом [красно-черное дерево](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D1%91%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE).

#### CopyOnWriteArraySet
Имплементаиця Set. Использует реализацию CopyOnWriteArrayList.<p>
1. Лучший выбор для приложений, которые не наращивают объемы данных и операции
   чтения сильно превышают операции изменения.
2. Потокобезопасная реализация
3. Операции изменения очень затратны, т.к копируют весь набор данных
4. Итераторы не поддерживают операции изменения
5. Итераторы быстры и не могут быть затронуты другими потоками, т.к. они
   зависят от отдельных снапшотов данных, сделаных во время вызова итератора.


#### ConcurrentSkipListSet
Имплементаиця NavigableSet. Базовые операции выполняются за log(n), аналогично TreeSet. Операции вставки, удаления и получения
выполняются потокобезопасно. Итераторы и сплитераторы слабосогласованны.
Это значит:
1. Они могут работать одновременно с другими операциями
2. Не выбросят ConcurrentModificationException, в отличии от fail-fast
3. Итератор проходится по элеменатам, какие они были при его создании, единожды.
   Однако, может отображать изменения, произошедшие после его создания (не гарантированно).

Операция size() не выполняется за постоянное время из-за многопоточной природы коллекции.
У операций с множеством элементов, формата .__All(), не гаранитруется атомарность по тем же причинам. 

## Queue

Имеет 8 имплементаций.


#### DelayQueue
Не ограниченная по размеру очередь, состоящая из элементов, имлементирущих интерфейс Delayed.
[Delayed](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Delayed.html) - интерфейс наследующий Comparble<Delayed>. Содержит метод getDelay, который принимает в себя время по ожиданию действия
над элементом. В случае с очередью это время по ожиданию доступа к элементу.
Так же надо имлементировать метод compareTo поскольку объекты внутри очереди будут ближе к концу очереди в случае если их

#### ConcurrentLinkedQueue
Не ограниченная по размеру потокобезопасная очередь основанная на связанных узлах.
Не допускает использование null-элементов.
Эта очередь использует эффективный не блокирующий алгоритм описанный в работе 
["Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms"](https://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf)
написанной авторами _Maged M. Michael_ и _Michael L. Scott_
Итераторы слабосогласованны, и возвращают элементы очереди в какой-то отдельный момент с момента создания итератора. 
Не выбрасывает ConcurrentModificationException.
<br>size() не является операцией выполняющейся за постоянное время из-за асинхронности и может выполняться ошибочно.
У операции с объемом элементов addAll, removeAll, retainAll, containsAll, equals, и toArray не гарантированна атомарность.

#### LinkedBlockingQueue
Опционально ограниченная по размеру блокирующая очередь, основанная на связанных узлах.
Связанные очереди обычно имеют большую пропускную способность, чем очереди основанные на массивах, однако менее предсказуемы
в плане производительности в многопоточных приложениях. Опциональный конструктор, который содержит ограничение по объему, нужен для того,
что бы избежать ненужного расширения. Если ограничение не объявленно - используется Integer.MAX_VALUE.
Связанные узлы создаются динамически.

#### ArrayBlockingQueue
Ограниченная по размеру блокирующая очередь представленная массивом. Порядок доступа к элментам FIFO.
Однажды созданная по заданому размеру, более не возможна к его изменению. Операции добавления в полную очередь приведут к блокированию
этой операции. Аналогично с извлечением из пустой. Поддерживает опциональную политику очередности для получения элементов из очереди.
По дефолту, очередность не гарантированна. Многопоточная реализация.

#### LinkedTransferQueue
Неограниченная очередь, имплементирует TransferQueue. Метод size() не выполняется за константное время из-ха асинхронной природы 
коллекции. У методы addAll, removeAll, retainAll, containsAll, equals, и toArray не гарантированна атомарность.
Отличатся тем, что потоки с операциями вставки блокируются до тех пор, пока другой поток не извлечет элемент. Такой подход 
используется во всех очередях наследующихся от TransferQueue.
При вызове метода tranfer() потребителем, блокирует операции вставки, если это необходимо.

#### PriorityQueue
Неограниченная блокирующая очередь, которая использует базирующаяся на _[приоритизированной куче](https://www.geeksforgeeks.org/priority-queue-using-binary-heap/)_
В нашем случае должен либо передаваться объект Comparable либо Comparator.
Приоритизированная куча имеет следующие свойства:
1. У каждого объекта есть свойство приоритета - в нашем случае сравнение приоритета происходит через известные интерфейсы
2. Элементы с меньшим приоритетом располагаются позже в очереди - compare/compareTo == -1
3. Если два элемента равны по приоритету, то они располагаются в порядке попадания в очередь - compare/compareTo == 0

Такая очередь не может содержать null элементы.
*Эта имплиментация не синхронизована*
Операции извлечения, удаления, получения, и добавления выполняются за O(log(n))
contains() и remove() выполняются за линейное время

#### PriorityBlockingQueue
Аналогична PriorityQueue, однако поддерживает блокировку на получение и вставку элементов.
Является импелемнтацией интерфейса BlockingQueue

#### SynchronousQueue
Синхронизированная очередь - разновидность блокирующей очереди, в которой операции вставки и удаления ожидают друг-друга и наоборот.
Не содержит никакого внутреннего объема и размера. Невозможно выполнить peek() поскольку элементы присутствуют только при
их удалении. Невозможно совершить вставку во время того, как другой поток пытается удалить элемент из очереди. Невозможно итерировать такую
очередь, если в ней нечего итерировать. Заглавным(Head) элементом такой очереди является элемент, поток которого первым пытается его добавить в 
эту очередь. Если такого потока нет, то poll() вернет null. Для других методов интерфейса Collection, например contains(), SynchronousQueue
ведет себя как пустая коллекция. Не принимает null элементы.
<br>Такие очереди подходят для передачи данных, в ходе которых объект из одного потока должен синхронизироваться, с объектом
из другого потока.
Во время вставки в эту очередь, он блокируется до извлечения элемента,
потому объема у нее нет. Служить буквально для передачи объектов.

### Dequeu

#### ConcurentLinkedDequeu
#### LinkedBlockingDequeu

### List

#### ArrayList
#### CopyOnWriteList
#### LinkedList
#### Stack
#### Vector

### Чеклист теории:

```
5 Целей фреймворка
11 Структурных элементов
9 Интерфейсов коллекций
4 Интерфейсов не коллекций
5 Многопоточных интерфейсов
12 Многопоточных реализаций

6 реализаций Set, 2 из 6 многопоточные
8 реализаций Queue, 6 из 9 многопоточные
```

## Использованные источники
1. Вольный перевод-конспект [оффициального сайта oracle](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html)
2. Вольный перевод-конспект [Javadoc](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/reference.html)
3. Использовал для более конкретного разбора LinkedTransferQueue [java-online](https://java-online.ru/concurrent-queue-block.xhtml#linkedTQ)
4. Разбор приоритизированной кучи [geeksforgeeks.com](https://www.geeksforgeeks.org/priority-queue-using-binary-heap/)